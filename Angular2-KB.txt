
	@@@@@@@@@@@@@@@@@

		Angular 2

	@@@@@@@@@@@@@@@@@



root module bootstrap
---------------------
change from RC4 to RC5+, instead of having bootstrap in main.ts, now the root component is bootstraped in

app.module.ts

1. import the root component:

  import { AppComponent } from './app.component';

2. declare in declarations:

@NgModule({
  declarations: [
    AppComponent
  ],

3. and announce that this component should be bootstraped:

  bootstrap: [AppComponent]

in main.ts
----------

we now import 

  import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

and execute .bootstrapModule(AppModule) method on it.  

adding other components
------------------------

Now instead of adding other components as directives on the root component as directives
add other components to app.module.ts:

  import { OtherComponent } from './other/other.component';

  @NgModule({
    declarations: [
      AppComponent,
      OtherComponent
    ],

angular-cli will do this when you run '$ ng g c other'

Advantage: when you declare other modules in app.module.ts, they are all available to 
other components.



======================================================================

  components
  ----------

Components are the main way we build and specify elements and logic on the page.

In angular 1, this was done with directives/controllers/scope.  In angular2, 
all those concepts are combined into components.

Here is a simple component:

import { Component } from '@angular/core';

  @Component({
    selector: 'my-component',
    // templateUrl: './my.component.html',
    // styleUrls: ['./my.component.css']
    template: '<div>Hello my name is {{name}}. <button (click)="sayMyName()">Say my name</button></div>'
  })
  export class MyComponent {
    console.log('My name is', this.name);
  }

selector
--------

  selectors work like a CSS selector.  so if we were to have 

    <my-component>

  element in our HTML document, angular would know what to load here.. 

  You can also use "hashtag" syntax:

    selector: '#app-root'

  Now, you can reference that selector via div id:

    <div id="app-root"> 




======================================================================

  Angular Modules 
  ***************

Angular Modules help organize an application into cohesive blocks of 
functionality.

Modules are a great way to organize the application and extend it with capabilities
from external libraries.  Many libraries are modules (e.g. FormsModule, HttpModule,
RouterModule).  Many 3rd party libs are available as Angular modules (e.g. Material
Design, Ionic, AngularFire2).

Modules consolidate components, directives and pipes into cohesive blocks of 
functionality, each focused on a feature area, application business domain, etc..

Modules can be loaded eagerly when the app starts, or lazy loaded asynch by the 
router.

Every Angular app has at least once module class - the root module.
We bootstrap that module to launch the application.

The root module is all we need in a simple application with a few components.
As the app grows, we refactor the root module into feature modules, and we
import these modules into root module.

An Angular Module is a class adorned with the @NgModule decorator function.

root module
-----------

By convention, root module is a class called 'AppModule' in a file named
app.module.ts

  import { NgModule }      from '@angular/core';
  import { BrowserModule } from '@angular/platform-browser';

  import
        { AppComponent }  from './app.component';

  @NgModule({
    imports: [ BrowserModule ],
    declarations: [ AppComponent ],
    bootstrap:    [ AppComponent ]
  })
  export class AppModule { }

NgModule
  this decorator defines the metadata for the module.
  this metadata imports a single helper module - BrowserModule - which 
  every browser app must import.

BrowserModule
  registers critical app service providers and 
  includes common directives like NgIf and NgFor

declarations
  this list identifies the application's only component, the root component
  "AppComponent"

bootstrap
  this property identies this AppComponent as the bootstrap component.
  When Angular launches the app, it places the HTML rendering of AppComponent
  in the DOM, inside the <my-app> element tags of the index.html.  

app/app.component.ts
----------------------



  

======================================================================

  View Encapsulation
  ------------------

angular 2 emulates the concept of shadow DOM:

  an HTML element has its 'shadow' DOM

<div>
  <component _nghost-pax-1>
    <h1 _ngcontent-pax-1>... </h1>
  </component>
  <h1>won't be styled the same</h1>
</div>

  This is based on CSS Attribute Selectors.

  a[target] {
    background-color: yellow;
  }

========================================================================

	Architecture
	*************

https://angular.io/docs/ts/latest/guide/architecture.html


Angular applications are composed of:
	1. HTML templates with angularized markup,
	2. component classes to manage those templates
	3. services with application logic
	4. modules combing components and services

You launch the app by bootstrapping the root module


8 main building blocks of an Angular app:

1. Modules
2. Components
3. Templates
4. Metadata
5. Data binding
6. Directives
7. Services
8. DI


1. Modules
-----------
	
	NOTE: JavaScript also has modules which are different from Angular modules.

	http://exploringjs.com/es6/ch_modules.html

	Prior to ES6, JS modules were implemented via libraries, not built into language.
	ES6 introduces JavaScript built-in modules.

	Angular ships as a collection of JS modules. think of them as library modules.
	Each Angular library name begins with the '@angular' prefix.
	YOu install them with npm, and import parts of them with JavaScript
	'import' statement:
		import { Component } from '@angular/core';


every app has at least one module - root - named "AppModule"
other modules are "feature" modules
each module is a cohesive block of code dedicated to an app domain, a workflow, 
or a closely related set of capabilities.

any module, root or feature, is a class with @NgModule decorator

	NgModule is a decorator function that takes a single metadata object whose
	properties describe a module.

		- declarations
			= view classes that belong to this module. 3 types of view classes:
				1. components
				2. directives
				3. pipes
		- exports
			= subset of the declarations that should be visible and usable 
			in the component templates of OTHER modules
		- imports
			= other modules whose exported classes are needed by component
			templates declared in this module
		- providers
			= creators of services that this module contributes 
			to the global collection of services
			they become accessible in all parts of the app
		- bootstrap [ROOT only]
			= the main application view, called 'root component'
			only ROOT module should set this "bootstrap" property

example of root module

	import { NgModule }      from '@angular/core';
	import { BrowserModule } from '@angular/platform-browser';

	@NgModule({
	  imports:      [ BrowserModule ],
	  providers:    [ Logger ],
	  declarations: [ AppComponent ],
	  exports:      [ AppComponent ], // just for demo - no one needs root module
	  bootstrap:    [ AppComponent ]
	})
	export class AppModule { }

bootstrap root in main.ts

app/main.ts:

	import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
	import { AppModule } from './app.module';

	platformBrowserDynamic().bootstrapModule(AppModule);

Angular modules and JavaScript modules

	be aware that you're using the two systems side by side:

		import { Component } from '@angular/core';
		.
		.
		.
		@NgModule({
			imports:	[ BrowserModule ],
			...
		})

2. Components
----------------------------------------

	 a component controls a patch of screen called a 'view'
	 e.g., the following views are controlled by components:
	 	- app root with navigation links
	 	- list of heros
	 	- hero editor

	you define a component's logic - what it does to support the view - inside
	a class.  The class interacts with the view thru an API of properties and
	methods.

    e.g. this HeroListcomponent has a 'heroes' property that returns an array
    of heroes that is acquires from a service.
    it also has a selectHero() method that sets a selectedHero property when
    a user clicks to choose a hero from that list.


3. Templates
----------------------------------------

  you define a component's view with its companion template.
  a template is a form of HTML that tells Angular how to render the component.
  In addition to HTML, templates use Angular's template syntax.




4. Metadata
----------------------------------------
5. Data binding
----------------------------------------
     

6. Directives
----------------------------------------
7. Services
----------------------------------------

  Service is a broad category encompassing any value, function, or feture that
  your application needs.

  Almost anything can be a service.
  Typically is a class with a narrow, well-defined purpose.
  Examples:
  - logging service
  - data service
  - message bus
  - tax calculator
  - application configuration

Angular has no definition of services.
There is no service base class, and no place to register a service.
Yet services are fundamental - components are big consumers of services.

example of a service class that logs to browser console:
app/logger.service.ts:

  export class Logger {
    log(msg: any) { console.log(msg); }
    error(msg: any) { console.error(msg); }
    warn(msg: any) { console.warn(msg); }
  }

example of HeroService that fetches heroes and returns them in a resolved
Promise.  This services also depends on the Logger service and another 
BackendService that handles the server comm grunt work:

app/hero.service.ts

  export class HeroService {
    private heroes: Hero[] = [];

    constructor(
      private backend: BackendService,
      private logger: Logger
    ) {}

    getHeroes() {
      this.backend.getAll(Hero).then(
        (heroes: Hero[]) => {
          // ... 
        });
      );
    }
  }

Component classes should be lean - they don't fetch data from the server,
validate user input, or log directly to the console.
They delegate such tasks to services.

A component's job is to enable the user experience - nothing more. 
It mediates between the view (rendered by the template) and the application
logic (which often includes some notion of a model).

A good component presents properties and methods for data binding.
It delegates everything non-trivial to services.




8. DI
----------------------------------------

Main points:

  injector - main DI mechanism

    maintains a container of service instances that it created

    can create a new service instance from a provider

  provider is a recipe for creating a service

  you register providers with injector
  
      
		 	
  Services and DI
  ---------------

Most dependencies are services - Angular uses DI to provide new components with the 
services they need.
Angular can tell which services a component needs by looking at the types of 
its constructor parameters.

E.g. constuctor of the HeroListcomponent:

  constructor(private service: HeroService) {}

When Angular creates the component, it asks an INJECTOR for the services that 
the component requires.

An injector maintains a container of service instances that it has previously
created.  If a requested service instance is not in the container, the 
injector makes one and adds it to the container before returning the service 
to Angular.

    How does the injector know how to make one?

You must have previously registered a PROVIDER of the HeroService with the 
injector.  A provider is something that can create or return a service, 
typically a service class itself.  You can register providers in modules or
in components.

In general, add providers to the root module so that the same instance of a
service is available everywhere.

    root module
    app/app.module.ts

      providers: [
        BackendService,
        HeroService,
        Logger
      ],

alternatively, register at a component level in the providers property of 
the @Component metadata:

  app/hero-list.component.ts

    @Component({
      moduleId: module.id,
      selector: 'hero-list',
      templateUrl: 'hero-list.component.html',
      providers: [ HeroService ]
    })

registering at a component level means you get a NEW instance of the service
with each NEW instance of that component.




==============================================================================

  template syntax
  ***************

https://angular.io/docs/ts/latest/guide/template-syntax.html

interpolation  
----------------------------------------

  {{title}}
  {{ 1 + 1 + getVal() }}


template expressions
----------------------------------------
  produces a value
  angular executes the expression, assigns it to a property of a binding
  target - a HTML element, a component, or a directive

    [property] = "expression"



template statements
----------------------------------------

  (event) = "statement"

  a template statement responds to an event raised by a binding target such as
  an element, component, or directive

  has side effect
  it's how we update application state from user input.
  there would be no point to responding to an event otherwise.

Data binding
************


  component logic interacts with component template (view)

  - string interpolation
    {{exp resolving to a string}}

  - property binding
    binding data to properties in your DOM
    <button [disabled] = "exp resolving to required value type">  

  - event binding 
    binding DOM events back to the model
    <button (click) = "expression handling the event">

  - two-way binding
    by default all Angular2 data binding is uni-diretional
    for performance reasons.
    <input [(ngModel)] = "bound model (e.g. object)">


binding syntax
----------------------------------------

  one-way
  from data source to view target   
        {{expression}}
        [target] = "expression"
        bind-target = "expression"

  one-way
  from view target to data source
        (target) = "statement"
        on-target = "statement"

  two-way
        [(target)] = "expression"
        bindon-target = "expression"



property binding
----------------------------------------
  we write a template property binding when we want to set a property of a
  view element to the value of a template expression. 
  e.g. binding the 'src' property of an image to 'heroImageUrl' property:

    <img [src] = "heroImageUrl">

  disabling a button when the component says that it "isUnchanged"

    <button [disabled] = "isUnchanged">Cancel is disabled</button>

  setting a property of a directive

    <div [ngClass] = "classes">[ngClass] binding to the classes property</div>
    <div (ngSubmit) = "..."></div>   

  binding to component properties

    <cmp [initObj] = "...">
    <cmp (rndEvent) = "...">    

  custom bindings

    Property Binding (@Input)

      @Input() propertyName: string 

    one-way in
    ----------

  property binding is described as "one-way data binding" because it
  flows a value in one direction, from a component's data property into
  a target element property.

    Event Binding (@Output)  
    .......................

      @Output() eventName = new EventEmitter();  
    or
      <button (click)="onClicked()">Click Me</button>

      onClicked() {
        alert('it worked');
      }

    Binding to Custom events
    ........................

      <button (click)="onClicked()">Click Me!</button>

      @Output() clicked = new EventEmitter<string>();
      onClicked() {
        this.clicked.emit('It Works!');
      }

      now, to consume this custom event:

      <app-event-binding (clicked)="onClicked($event)"></app-event-binding>
      and in this component.ts:

      onClicked(value: string) {
        alert(value);
      }



attribute, class and style bindings
----------------------------------------
event binding
----------------------------------------
two-way binding
----------------------------------------
built-in directives
----------------------------------------
* and <template>
----------------------------------------
template reference variables
----------------------------------------
input and output properties
----------------------------------------


		 	

==============================================================================

  angular component lifecycle
  ***************************
https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html

ngOnChanges
ngOnInit
ngDoCheck

  ngAfterContentInit
  ngAfterContentChecked
  ngAfterViewInit
  ngAfterViewChecked

ngOnDestroy

==============================================================================

  Twitter Bootstrap

@see angular-cli

==============================================================================

  creating a new service
  **********************

  $ ng g s <service-name> --flat --spec 

    --flat (default: true)


create config service
---------------------
$ mkdir src/app/shared
craiskin@xubi-one:~/ws/standard/iam/iam-demo-ng2-product-app $ ng g s shared/Config
installing service
  create src/app/shared/config.service.spec.ts
  create src/app/shared/config.service.ts
  WARNING Service is generated but not provided, it must be provided to be used

create mdm product service
$ ng g s MdmProduct
installing service
  create src/app/mdm-product.service.spec.ts
  create src/app/mdm-product.service.ts
  WARNING Service is generated but not provided, it must be provided to be used


create ConfigService
--------------------

import { Injectable } from '@angular/core';
import { environment } from '../../environments/environment';

@Injectable()
export class ConfigService {
  public production: boolean = environment.production;
  public mdmProductServer: string = environment.MDM_PRODUCT_SERVER;
  public mdmProductApi: string = environment.MDM_PRODUCT_API;

  public mdmProductApiURL(): string {
    return this.mdmProductServer + this.mdmProductApi;
  }
}


Provide ConfigService in @NgModule AppModule:
---------------------------------------------

import { AppComponent } from './app.component';
import { environment } from '../environments/environment';
import { ConfigService } from './shared/config.service';


@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule,
    AlertModule
  ],
  providers: [ ConfigService ],
  bootstrap: [AppComponent]
})
export class AppModule {

  constructor() { }
}

use ConfigService in MdmProductService
--------------------------------------

import { Injectable } from '@angular/core';
import { ConfigService } from './shared/config.service';

@Injectable()
export class MdmProductService {

  constructor(private configService: ConfigService) { 
    console.log(`
      I'm MdmProductService, and I'm configured with ConfigService
      ConfigService.mdmProductServer: ${configService.mdmProductApiURL()}
    `);
  }

}





================================================================================





