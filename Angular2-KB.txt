
	@@@@@@@@@@@@@@@@@

		Angular 2

	@@@@@@@@@@@@@@@@@



root module bootstrap
---------------------
change from RC4 to RC5+, instead of having bootstrap in main.ts, now the root component is bootstraped in

app.module.ts

1. import the root component:

  import { AppComponent } from './app.component';

2. declare in declarations:

@NgModule({
  declarations: [
    AppComponent
  ],

3. and announce that this component should be bootstraped:

  bootstrap: [AppComponent]

in main.ts
----------

we now import 

  import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

and execute .bootstrapModule(AppModule) method on it.  

adding other components
------------------------

Now instead of adding other components as directives on the root component as directives
add other components to app.module.ts:

  import { OtherComponent } from './other/other.component';

  @NgModule({
    declarations: [
      AppComponent,
      OtherComponent
    ],

angular-cli will do this when you run '$ ng g c other'

Advantage: when you declare other modules in app.module.ts, they are all available to 
other components.



======================================================================

  components
  ----------

Components are the main way we build and specify elements and logic on the page.

In angular 1, this was done with directives/controllers/scope.  In angular2, 
all those concepts are combined into components.

Here is a simple component:

import { Component } from '@angular/core';

  @Component({
    selector: 'my-component',
    // templateUrl: './my.component.html',
    // styleUrls: ['./my.component.css']
    template: '<div>Hello my name is {{name}}. <button (click)="sayMyName()">Say my name</button></div>'
  })
  export class MyComponent {
    console.log('My name is', this.name);
  }

selector
--------

  selectors work like a CSS selector.  so if we were to have 

    <my-component>

  element in our HTML document, angular would know what to load here.. 

  You can also use "hashtag" syntax:

    selector: '#app-root'

  Now, you can reference that selector via div id:

    <div id="app-root"> 




======================================================================

  Angular Modules 
  ***************

Angular Modules help organize an application into cohesive blocks of 
functionality.

Modules are a great way to organize the application and extend it with capabilities
from external libraries.  Many libraries are modules (e.g. FormsModule, HttpModule,
RouterModule).  Many 3rd party libs are available as Angular modules (e.g. Material
Design, Ionic, AngularFire2).

Modules consolidate components, directives and pipes into cohesive blocks of 
functionality, each focused on a feature area, application business domain, etc..

Modules can be loaded eagerly when the app starts, or lazy loaded asynch by the 
router.

Every Angular app has at least once module class - the root module.
We bootstrap that module to launch the application.

The root module is all we need in a simple application with a few components.
As the app grows, we refactor the root module into feature modules, and we
import these modules into root module.

An Angular Module is a class adorned with the @NgModule decorator function.

root module
-----------

By convention, root module is a class called 'AppModule' in a file named
app.module.ts

  import { NgModule }      from '@angular/core';
  import { BrowserModule } from '@angular/platform-browser';

  import
        { AppComponent }  from './app.component';

  @NgModule({
    imports: [ BrowserModule ],
    declarations: [ AppComponent ],
    bootstrap:    [ AppComponent ]
  })
  export class AppModule { }

NgModule
  this decorator defines the metadata for the module.
  this metadata imports a single helper module - BrowserModule - which 
  every browser app must import.

BrowserModule
  registers critical app service providers and 
  includes common directives like NgIf and NgFor

declarations
  this list identifies the application's only component, the root component
  "AppComponent"

bootstrap
  this property identies this AppComponent as the bootstrap component.
  When Angular launches the app, it places the HTML rendering of AppComponent
  in the DOM, inside the <my-app> element tags of the index.html.  

app/app.component.ts
----------------------



  

======================================================================

  View Encapsulation
  ------------------

angular 2 emulates the concept of shadow DOM:

  an HTML element has its 'shadow' DOM

<div>
  <component _nghost-pax-1>
    <h1 _ngcontent-pax-1>... </h1>
  </component>
  <h1>won't be styled the same</h1>
</div>

  This is based on CSS Attribute Selectors.

  a[target] {
    background-color: yellow;
  }

========================================================================

	Architecture
	*************

https://angular.io/docs/ts/latest/guide/architecture.html


Angular applications are composed of:
	1. HTML templates with angularized markup,
	2. component classes to manage those templates
	3. services with application logic
	4. modules combing components and services

You launch the app by bootstrapping the root module


8 main building blocks of an Angular app:

1. Modules
2. Components
3. Templates
4. Metadata
5. Data binding
6. Directives
7. Services
8. DI


1. Modules
-----------
	
	NOTE: JavaScript also has modules which are different from Angular modules.

	http://exploringjs.com/es6/ch_modules.html

	Prior to ES6, JS modules were implemented via libraries, not built into language.
	ES6 introduces JavaScript built-in modules.

	Angular ships as a collection of JS modules. think of them as library modules.
	Each Angular library name begins with the '@angular' prefix.
	YOu install them with npm, and import parts of them with JavaScript
	'import' statement:
		import { Component } from '@angular/core';


every app has at least one module - root - named "AppModule"
other modules are "feature" modules
each module is a cohesive block of code dedicated to an app domain, a workflow, 
or a closely related set of capabilities.

any module, root or feature, is a class with @NgModule decorator

	NgModule is a decorator function that takes a single metadata object whose
	properties describe a module.

		- declarations
			= view classes that belong to this module. 3 types of view classes:
				1. components
				2. directives
				3. pipes
		- exports
			= subset of the declarations that should be visible and usable 
			in the component templates of OTHER modules
		- imports
			= other modules whose exported classes are needed by component
			templates declared in this module
		- providers
			= creators of services that this module contributes 
			to the global collection of services
			they become accessible in all parts of the app
		- bootstrap [ROOT only]
			= the main application view, called 'root component'
			only ROOT module should set this "bootstrap" property

example of root module

	import { NgModule }      from '@angular/core';
	import { BrowserModule } from '@angular/platform-browser';

	@NgModule({
	  imports:      [ BrowserModule ],
	  providers:    [ Logger ],
	  declarations: [ AppComponent ],
	  exports:      [ AppComponent ], // just for demo - no one needs root module
	  bootstrap:    [ AppComponent ]
	})
	export class AppModule { }

bootstrap root in main.ts

app/main.ts:

	import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
	import { AppModule } from './app.module';

	platformBrowserDynamic().bootstrapModule(AppModule);

Angular modules and JavaScript modules

	be aware that you're using the two systems side by side:

		import { Component } from '@angular/core';
		.
		.
		.
		@NgModule({
			imports:	[ BrowserModule ],
			...
		})

2. Components
----------------------------------------

	 a component controls a patch of screen called a 'view'
	 e.g., the following views are controlled by components:
	 	- app root with navigation links
	 	- list of heros
	 	- hero editor

	you define a component's logic - what it does to support the view - inside
	a class.  The class interacts with the view thru an API of properties and
	methods.

    e.g. this HeroListcomponent has a 'heroes' property that returns an array
    of heroes that is acquires from a service.
    it also has a selectHero() method that sets a selectedHero property when
    a user clicks to choose a hero from that list.


3. Templates
----------------------------------------

  you define a component's view with its companion template.
  a template is a form of HTML that tells Angular how to render the component.
  In addition to HTML, templates use Angular's template syntax.




4. Metadata
----------------------------------------
5. Data binding
----------------------------------------
     

6. Directives
----------------------------------------
7. Services
----------------------------------------

  Service is a broad category encompassing any value, function, or feture that
  your application needs.

  Almost anything can be a service.
  Typically is a class with a narrow, well-defined purpose.
  Examples:
  - logging service
  - data service
  - message bus
  - tax calculator
  - application configuration

Angular has no definition of services.
There is no service base class, and no place to register a service.
Yet services are fundamental - components are big consumers of services.

example of a service class that logs to browser console:
app/logger.service.ts:

  export class Logger {
    log(msg: any) { console.log(msg); }
    error(msg: any) { console.error(msg); }
    warn(msg: any) { console.warn(msg); }
  }

example of HeroService that fetches heroes and returns them in a resolved
Promise.  This services also depends on the Logger service and another 
BackendService that handles the server comm grunt work:

app/hero.service.ts

  export class HeroService {
    private heroes: Hero[] = [];

    constructor(
      private backend: BackendService,
      private logger: Logger
    ) {}

    getHeroes() {
      this.backend.getAll(Hero).then(
        (heroes: Hero[]) => {
          // ... 
        });
      );
    }
  }

Component classes should be lean - they don't fetch data from the server,
validate user input, or log directly to the console.
They delegate such tasks to services.

A component's job is to enable the user experience - nothing more. 
It mediates between the view (rendered by the template) and the application
logic (which often includes some notion of a model).

A good component presents properties and methods for data binding.
It delegates everything non-trivial to services.




8. DI
----------------------------------------

Main points:

  injector - main DI mechanism

    maintains a container of service instances that it created

    can create a new service instance from a provider

  provider is a recipe for creating a service

  you register providers with injector
  
      
		 	
  Services and DI
  ---------------

Most dependencies are services - Angular uses DI to provide new components with the 
services they need.
Angular can tell which services a component needs by looking at the types of 
its constructor parameters.

E.g. constuctor of the HeroListcomponent:

  constructor(private service: HeroService) {}

When Angular creates the component, it asks an INJECTOR for the services that 
the component requires.

An injector maintains a container of service instances that it has previously
created.  If a requested service instance is not in the container, the 
injector makes one and adds it to the container before returning the service 
to Angular.

    How does the injector know how to make one?

You must have previously registered a PROVIDER of the HeroService with the 
injector.  A provider is something that can create or return a service, 
typically a service class itself.  You can register providers in modules or
in components.

In general, add providers to the root module so that the same instance of a
service is available everywhere.

    root module
    app/app.module.ts

      providers: [
        BackendService,
        HeroService,
        Logger
      ],

alternatively, register at a component level in the providers property of 
the @Component metadata:

  app/hero-list.component.ts

    @Component({
      moduleId: module.id,
      selector: 'hero-list',
      templateUrl: 'hero-list.component.html',
      providers: [ HeroService ]
    })

registering at a component level means you get a NEW instance of the service
with each NEW instance of that component.




==============================================================================

  template syntax
  ***************

https://angular.io/docs/ts/latest/guide/template-syntax.html

interpolation  
----------------------------------------

  {{title}}
  {{ 1 + 1 + getVal() }}


template expressions
----------------------------------------
  produces a value
  angular executes the expression, assigns it to a property of a binding
  target - a HTML element, a component, or a directive

    [property] = "expression"



template statements
----------------------------------------

  (event) = "statement"

  a template statement responds to an event raised by a binding target such as
  an element, component, or directive

  has side effect
  it's how we update application state from user input.
  there would be no point to responding to an event otherwise.

Data binding
************


  component logic interacts with component template (view)

  - string interpolation
    {{exp resolving to a string}}

  - property binding
    binding data to properties in your DOM
    <button [disabled] = "exp resolving to required value type">  

  - event binding 
    binding DOM events back to the model
    <button (click) = "expression handling the event">

  - two-way binding
    by default all Angular2 data binding is uni-diretional
    for performance reasons.
    <input [(ngModel)] = "bound model (e.g. object)">


binding syntax
----------------------------------------

  one-way
  from data source to view target   
        {{expression}}
        [target] = "expression"
        bind-target = "expression"

  one-way
  from view target to data source
        (target) = "statement"
        on-target = "statement"

  two-way
        [(target)] = "expression"
        bindon-target = "expression"



property binding
----------------------------------------
  we write a template property binding when we want to set a property of a
  view element to the value of a template expression. 
  e.g. binding the 'src' property of an image to 'heroImageUrl' property:

    <img [src] = "heroImageUrl">

  disabling a button when the component says that it "isUnchanged"

    <button [disabled] = "isUnchanged">Cancel is disabled</button>

  setting a property of a directive

    <div [ngClass] = "classes">[ngClass] binding to the classes property</div>
    <div (ngSubmit) = "..."></div>   

  binding to component properties

    <cmp [initObj] = "...">
    <cmp (rndEvent) = "...">    

  custom bindings

    Property Binding (@Input)

      @Input() propertyName: string 

    one-way in
    ----------

  property binding is described as "one-way data binding" because it
  flows a value in one direction, from a component's data property into
  a target element property.

    Event Binding (@Output)  
    .......................

      @Output() eventName = new EventEmitter();  
    or
      <button (click)="onClicked()">Click Me</button>

      onClicked() {
        alert('it worked');
      }

    Binding to Custom events
    ........................

      <button (click)="onClicked()">Click Me!</button>

      @Output() clicked = new EventEmitter<string>();
      onClicked() {
        this.clicked.emit('It Works!');
      }

      now, to consume this custom event:

      <app-event-binding (clicked)="onClicked($event)"></app-event-binding>
      and in this component.ts:

      onClicked(value: string) {
        alert(value);
      }



attribute, class and style bindings
----------------------------------------
event binding
----------------------------------------
two-way binding
----------------------------------------
built-in directives
----------------------------------------
* and <template>
----------------------------------------
template reference variables
----------------------------------------
input and output properties
----------------------------------------


		 	

==============================================================================

  angular component lifecycle
  ***************************
https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html

ngOnChanges
ngOnInit
ngDoCheck

  ngAfterContentInit
  ngAfterContentChecked
  ngAfterViewInit
  ngAfterViewChecked

ngOnDestroy

==============================================================================

  Twitter Bootstrap

@see angular-cli

==============================================================================

  creating a new service
  **********************

  $ ng g s <service-name> --flat --spec 

    --flat (default: true)


create config service
---------------------
$ mkdir src/app/shared
craiskin@xubi-one:~/ws/standard/iam/iam-demo-ng2-product-app $ ng g s shared/Config
installing service
  create src/app/shared/config.service.spec.ts
  create src/app/shared/config.service.ts
  WARNING Service is generated but not provided, it must be provided to be used

create mdm product service
$ ng g s MdmProduct
installing service
  create src/app/mdm-product.service.spec.ts
  create src/app/mdm-product.service.ts
  WARNING Service is generated but not provided, it must be provided to be used


create ConfigService
--------------------

import { Injectable } from '@angular/core';
import { environment } from '../../environments/environment';

@Injectable()
export class ConfigService {
  public production: boolean = environment.production;
  public mdmProductServer: string = environment.MDM_PRODUCT_SERVER;
  public mdmProductApi: string = environment.MDM_PRODUCT_API;

  public mdmProductApiURL(): string {
    return this.mdmProductServer + this.mdmProductApi;
  }
}


Provide ConfigService in @NgModule AppModule:
---------------------------------------------

import { AppComponent } from './app.component';
import { environment } from '../environments/environment';
import { ConfigService } from './shared/config.service';


@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule,
    AlertModule
  ],
  providers: [ ConfigService ],
  bootstrap: [AppComponent]
})
export class AppModule {

  constructor() { }
}

use ConfigService in MdmProductService
--------------------------------------

import { Injectable } from '@angular/core';
import { ConfigService } from './shared/config.service';

@Injectable()
export class MdmProductService {

  constructor(private configService: ConfigService) { 
    console.log(`
      I'm MdmProductService, and I'm configured with ConfigService
      ConfigService.mdmProductServer: ${configService.mdmProductApiURL()}
    `);
  }

}

================================================================================

  Functional Reactive Programming FRP
  ***********************************

Tutorial 1
https://github.com/channikhabra/frp-with-rxjs-jschannel-conf/blob/master/README.org

Task: 
 - render tweets to a web page
 - tweet looks like this
      var tweets = [
        {
          id: 'tweet1',
          username: 'koyote',
          body: 'I will eventually catch you :3'
        }
        ...
      (100 or so)];
Dev spec:
  - only show tweets from the logged-in user
  - only show the tweets with specific hash-tags
  - and replace the text emogies with images.

So, the dev starts coding one problem at a time:

var tweets = getTweets();
tweets
    .filter(t => t.username === me.username)   // filter tweets from this user
    .filter(t => hasTag(selectedHTag, t.text)  // only tweets with selected #tag
    .map(t => {
      t.text = emogize(t.text);
      return t;
    })                     // replace text emogies with <img> tags
                           // map is like filter but it takes a function... 
    .forEach(t => render); // for each item in the processed collection, render...


Code:

    tweets
      .filter(t => t.username === me.username)
      .filter(t => t.text.split(' ').includes(selectedHTag))
      .map(t => {
        t.text = emogize(t.text);
        return t;
      })
      .forEach(t => render);

Source
    +---------------------------+
    |                           |
    |        operations         |
    |                           |
    +---------------------------+
                              Sink

The data source is made to go through an operation, and the result is passed to
a sink for side effects.
The operations will not mutate the source.
Given the same input, it will always produce same output - it's a pure function.
Pure functions can be composed to make complex operations without any hassle.

This functional approach brings a lot of value:

  1. the code is readable
  2. pure functions are easy to test
  3. modular, compose-able code means ease of extension

But this is JavaScript - turns out the source is asynchronous, and it produces
one tweet at a time.

First thing that came to mind - callbacks

  - composability.. how would you compose with callbacks?
  - dangling state can be nasty. imagine 6 levels deep with callbacks.  5th
  uses something set by 2nd callback.  now debug
  - readability is the first thing that gets murdered.

Promises?

Thanks to promises, async values can be passed around like regular data.
but they are hard to compose.
they resolve once at most and then be done with, and canceling a promise is not
something you do in a pool of async requests

with RxJS
----------

var tweets_ = Rx.Observable.fromPromise(getTweets);

tweets_
    .filter(t => t.username === me.username)
    .filter(t => hasTag(selectedTag) )
    .map(t => {
      t.text = emogize(t.text);
      return t;
    })
    .subscribe(x => render(x));



================================================================================

  Reactive Programming for Angular2
  *********************************

Stream
  = sequence of values in time

  e.g. stream of numeric values issued one every second

  e.g. sequence of mouse clicks, with the (x, y) coordinates of the mouse click

    (100,200), (110,300), (400, 50) ...

  everything that happens in the browser can be seen as a stream: the sequence
  of browser event that are triggered when the user interacts with the page,
  data arriving from the server, timeouts getting triggered..

  In order for the notion of stream to be useful to build a program, we need
  a way to create streams, subscribe to them, react to new values, and 
  combine streams together to build new ones

Observable

  your API for working with a stream:
    - define a stream
    - subscribe to it
    - transform it

RxJS
------------

  = Reactive Extensions for JS
  = implementations of Observables for JS
                  


================================================================================

  Observables
  ***********

https://miguelmota.com/blog/getting-started-with-rxjs/
  

is one of many ways of representing async values in JavaScript
it's a lot like a Promise, but acts more like a collection of async values
they are a first class async values like a promise is

think of it as an array spanned over time
it gets its values in future, and may or may not finish.

Plural of Promise is an Observable.
Observable in RxJS aims to mimic the interface of Array extras.


of method
---------
  you can use of() to use a single value as an Observable.
  with Observables, nothing gets run until there is a subscribe listening
  to the Observable.  The Observer on the subscribe() method will contain the
  final result as the parameter.


hello world

  Rx.Observable.of('hello world')
    .subscribe(result => console.log(result));  // prints 'hello world'

from method
-----------

  from() method creates an Observable sequence from arrays, array-like objects
  or iterables such as Map, Set, or string

    const set = new Set<number>([1,2,3]);
    Rx.Observable.from(set)
        .map(x => x*2)
        .subscribe(x => console.log(x),
                  error => console.error(error),
                  () => console.log('done'));   

fromEvent() method
------------------

  use to create an Observable from an event listener.  In this example, we log
  the coordinates of the mouse position.

  Rx.Observable.fromEvent(document, 'mousemove')
    .subscribe(event => console.log(event.clientX, event.clientY));

  Output:

  95 292
  107 292
  141 297
  173 305
  ...    


You can create new observables based on the original ones:
----------------------------------------------------------

const mouseMoves = Rx.Observable.fromEvent(document, `mousemove`)

const movesOnRight = mouseMoves.filter(event => event.clientX > window.innerWidth / 2);
const movesOnLeft = mouseMoves.filter(event => event.clientX > window.innerWidth / 2);

movesOnRight.subscribe(event => console.log(`Right side`, event.clientX, event.clientY));
movesOnLeft.subscribe(event => console.log(`Left side`, event.clientX, event.clientY));

In Rx, methods that transform or query sequences are called operators.
Above, filters() are operators.

Now imagine, you wanted to get coordinates of 10 clicks that occur on the 
right side of the screen - like a SQL db query:

  SELECT x,y FROM clicks LIMIT 10

Traditional imperative, non-declarative way:

    let clicks = 0;

    document.addEventListener('click', function clickHandler(event) {
      if (clicks < 10) {
        if (event.clientX > window.innerWidth / 2) {
          console.log(event.clientX, event.clientY);
          clicks += 1;
        }
      } else {
        document.removeEventListener('click', clickHandler);
      }
    });


RxJS version:

    Rx.Observable.fromEvent(document, 'click')
    .filter(event => event.clientX > window.innerWidth / 2)
    .take(10)
    .subscribe(data => console.log(data.clientX, data.clientY))    



bindCallback() method
---------------------

  useful when you want to create an Observable from a function that invokes a
  callback with the value.

    const hello = (message, callback) => callback(`Hello ${message}`);
    const sayHello = Rx.Observable.bindCallback(hello);

    const source = sayHello('World');
    source.subscribe(result => console.log(result));


fromPromise() method
--------------------

  useful to create an Observable from a Promise

    const promise = new Promise( (resolve, reject) => resolve('Hello World') );

    const subscription = Rx.Observable.fromPromise(promise)
    .subscribe(
          x => console.log(x),
          error => console.error(error),
          () => console.log('done')
        );


================================================================================

  Observer pattern
  ****************

https://miguelmota.com/blog/getting-started-with-rxjs/

In the Observer pattern, aka Publisher/Subscriber pattern, there is an object
called Producer (aka Subject) that keeps references of all listeners (aka
Subscribers) subscribed to it.

  console.log("------ Observer pattern -------");

  class Producer {

    listeners: any[];

    constructor() {
      this.listeners = [];
    }

    public add(listener: any): void {
      this.listeners.push(listener);
    }

    public remove(listener: any): void {
      var index = this.listeners.indexOf(listener);
      this.listeners.splice(index, 1);
    }

    public notify(message): void {
      this.listeners.forEach(listener => listener(message));
    }
  }

  const notifier = new Producer();
  const listener = (message) => console.log(`Listerner received message: ${message}`);

  notifier.add(listener);
  notifier.notify('Hello');



================================================================================

  RxJS Angular2 pitfalls
  **********************
http://blog.angular-university.io/angular-2-rxjs-common-pitfalls/

pitfall 1 - nothing happens
---------------------------





================================================================================





